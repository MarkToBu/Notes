# 1 Mybatis框架

## 含义和特点

```
1 mybatis和 Hibernate一样，都是持久层的ORM框架
2 mybatis底层也是驱动的jdbc，也是对数据库的 CURD
3 mybatis的特点：sql语句的映射。[mybatis中所有的sql语句都是程序员自己写的，但也会自动执行，自动返回结果]
	所以，mybatis是一个半自动的框架
4 mybatis经常被称为sql的映射框架
```

## mybatis和Hibernate和jdbc的比较

```
1 jdbc--全手动的===》手写sql-手动执行sql-手动返回结果 效率最高 代码冗余
2 Hibernate 全自动===》自动生成sql 自动执行sql-自动返回结果 效率最低 代码简洁
3 mybatis 半自动 ===》手写sql 自动执行 自动返回结果 效率比Hibernate高 sql开发量大 移植性弱
```

## mybatis的核心api

```
1．org.apache.ibatis.session.SqlSessionFactoryBuilder:
（1）build
2．SqlSessionFactory:   
（1）openSession
------------工厂的连接
3．SqlSession:
（1）Insert(String sqlid)
（2）Update(String sqlid) 
（3）Delete(String sqlid)
（4）selectOne() selectList()
```

## mybatis中的配置文件

### 属性文件

```xml
1 mybatis的属性文件====》Config.xml---用来配置连接数据库的信息
---------------------------------------------------------------------------------------------------
<configuration>
	用来连接另一个存储连接的文件
    <properties resource="db.properties"></properties>
    <settings>
        <setting name="logImpl" value="LOG4J"/>
    </settings>
    <!--起别名-->
    <typeAliases>
        <!--起别名 类型com.etoak.entity.Student==>stu alias= 起别名-->
        <typeAlias type="com.etoak.entity.Student" alias="stu"></typeAlias>
    </typeAliases>
    可以用来连接多个数据库
    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"></transactionManager>
            <dataSource type="POOLED">
                <property name="driver" value="${m.driver}"></property>
                <property name="url" value="${m.url}"></property>
                <property name="username" value="${m.user}"></property>
                <property name="password" value="${m.pwd}"></property>
            </dataSource>
        </environment>
        <environment id="oracle">
            <transactionManager type="JDBC"></transactionManager>
            <dataSource type="POOLED">
                <property name="driver" value="${o.driver}"></property>
                <property name="url" value="${o.url}"></property>
                <property name="username" value="${o.user}"></property>
                <property name="password" value="${o.pwd}"></property>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="com/etoak/entity/StudentMapper.xml"></mapper>
        <mapper resource="com/etoak/entity/SMapper.xml"></mapper>
       <!-- <mapper resource="com/etoak/entity/StudentMapper1.xml"></mapper>
        <mapper resource="com/etoak/entity/SMapper1.xml"></mapper>-->
    </mappers>
</configuration>
```

#### [1] 起别名

```
 <!--起别名-->
 <typeAliases>
      <!--起别名 类型com.etoak.entity.Student==>stu alias= 起别名-->
      <typeAlias type="com.etoak.entity.Student" alias="stu"></typeAlias>
 </typeAliases>
 1 通过给实体类对象起别名-可以简化代码
```

#### [2] 连接另一个文件

```xml
 <properties resource="db.properties"></properties>
 ----------------------------------db.properties----------------------
 m.driver=com.mysql.jdbc.Driver
 m.url=jdbc:mysql:///et1803
 m.username=root
 m.password=etoak
 ---------------------------------------------------------------------
  <environment id="mysql">
         <transactionManager type="JDBC"></transactionManager>
         <dataSource type="POOLED">
             <property name="driver" value="${m.driver}"></property>
             <property name="url" value="${m.url}"></property>
             <property name="username" value="${m.user}"></property>
             <property name="password" value="${m.pwd}"></property>
         </dataSource>
    </environment>
```

### 映射文件

```xml
1 映射文件用来对数据库进行CURD的
---------------------------------------------------------------------------------------------
<!--<insert id="addStu" parameterType="stu">
        /*返回获得主键 keyproperty表示类中的主键属性 resultType返回的属性*/
        <selectKey keyProperty="id" resultType="int">
            select last_insert_id as id
        </selectKey>
        INSERT  into stu(s_name,s_age,s_birth)
        VALUES
        (#{name},#{age},#{birth})
    </insert>--》
    <select id="queryById" parameterType="int" resultMap="rMap_stu">
        select * from stu where s_id =#{id}
    </select>-->
-------------------------动态查询标签---------------------------------------

```

## 添加数据时如何获得主键

```xml
1 jdbc是手动获得
2 mybatis-----<selectKey keyProperty="id" resultType="int" order="defore/after">
		mysql:
			字符串：replace(uuid,'-','')
			数字：select last_insert_id() as id
		oracle
			字符串：select sys_guid() as id
			数字：
				1 序列：select  etoak_seq.nextval as id from dual--前提数数据库中必须有数列
				2 最大值+1 select max(id)+1 from xxx
```

## 流程

```
1 导包
2 拷贝日志文件
3 写工厂
4 编写属性文件
5 实体类
6 dao层接口
7 编写映射文件
8 编写service--相当于写dao层的实现类
9 返回查询出来的东西
```

## 修改连接的表的字段名字

```
<resultMap id="BaseResultMap1" type="com.etoak.book.books.entity.Book" >
    <!--
      WARNING - @mbggenerated
      This element is automatically generated by MyBatis Generator, do not modify.
      This element was generated on Wed Jun 06 16:26:17 CST 2018.
    -->
    <id column="bid" property="id" jdbcType="VARCHAR" />
    <result column="bname" property="name" jdbcType="VARCHAR" />
    <result column="price" property="price" jdbcType="INTEGER" />
    <result column="author" property="author" jdbcType="VARCHAR" />
    <result column="publishdate" property="publishdate" jdbcType="TIMESTAMP" />
    <result column="categoryid" property="categoryid" jdbcType="VARCHAR" />
    <result column="status" property="status" jdbcType="VARCHAR" />
    ca--是指两个表之间的关联的属性 
    category--关联属性的类型
    categoryid---列的字段的名字
    <association property="ca" javaType="category" column="categoryid">
    	<id property="id" column="caid"/>
    	<result property="name" column="caname"></result>
    </association>
  </resultMap>
```

## getResourceAsStream和getClassLoader的区别

```
1 Class.getResourceAsStream(../../../Config.xml);--得跳出当前的当前的包，然后去解析Config.xml文件
2 Class.getCalssLoader().getResourceAsStream("Config.xml");--直接获取当前的路径，去解析config.xml文件
```

## mybatis中#和$的区别

```
1 #相当于 preparedStatement 支持占位符
2 $相当于普通的Statement,不支持占位符，条件都是直接拼接的
3 但是，有些情况下必须使用$
	1):select * from student where name like '${name}'
		et
		#==> select * from student where name like '"et"'
		$==> select * from student where name like 'et'
	2):select * from ${tablename}
		#==> select * from  "student"
		$==> select * from student
	3):?占位符用在 where 后边 update set后边 delete where，insert values 后边，但是其他的地方不能用
```

## 实体类和数据库中表中的字段不对应的情况

```
1 添加的时候
	insert into tablename(s_id,s_name[字段的名字]) values(id,name[实体类中的名字]);
2 查询的时候
	1）：起别名
	
	<!--表和类之间的字段不对应的时候 查询 起别名-->
    <!--<select id="queryById1" parameterType="int" resultType="stu">
        select
         s_id as id,
         s_name as name,
         s_age as age,
         s_birth as birth
         from stu where s_id =#{id}
    </select>-->
    
    2）通过resultMap映射
    
    <!-- 还有一种是使用resultMap-->
    <!--<resultMap id="rMap_stu" type="stu">
        <id property="id" column="s_id"></id>
        <result property="name" column="s_name"></result>
        <result property="age" column="s_age"></result>
        <result property="birth" column="s_birth"></result>
    </resultMap>
```

## 当表级联的时候，取别名

```
<resultMap id="BaseResultMap1" type="com.etoak.book.books.entity.Book" >
    <!--
      WARNING - @mbggenerated
      This element is automatically generated by MyBatis Generator, do not modify.
      This element was generated on Wed Jun 06 16:26:17 CST 2018.
    -->
    <id column="bid" property="id" jdbcType="VARCHAR" />
    <result column="bname" property="name" jdbcType="VARCHAR" />
    <result column="price" property="price" jdbcType="INTEGER" />
    <result column="author" property="author" jdbcType="VARCHAR" />
    <result column="publishdate" property="publishdate" jdbcType="TIMESTAMP" />
    <result column="categoryid" property="categoryid" jdbcType="VARCHAR" />
    <result column="status" property="status" jdbcType="VARCHAR" />
    给级联的表，取别名(当查询的东西在两个表中)
    <association property="ca" javaType="category" column="categoryid">
    	<id property="id" column="caid"/>
    	<result property="name" column="caname"></result>
    </association>
  </resultMap>
```

## mybatis中的动态查询标签

```xml
1 封装一段sql语句，到时候可以直接<include>引用--重复利用率较高
	<sql id="columns_list">s_id as id ,s_name as name,s_age as age,s_birth as birth</sql>9
	<sql id="commonsql">select <include refid="columns_list"></include> from stu</sql>
2 引用的案例	
    <select id="queryStu" parameterType="int" resultType="stu">
            <!--include:表示引入上边的 sql片段-->
            <include refid="commonsql"></include> 可以直接引用
            where  s_id=#{id}
    </select>
3 动态查询标签--where if
    <select id="querySomeStu" parameterType="map" resultType="stu">
        <include refid="commonsql"></include>
        <where> where和if条件语句可以自动判断
            <if test="name!=null">
                 and s_name like '%${name}%'
            </if>
            <if test="age!=null">
                and  s_age=#{age}
            </if>
        </where>
        limit #{start},#{max}
    </select>
4 动态查询标签--foreach--》可以用来批量查询
    <select id="queryByAge" parameterType="map" resultType="stu">
        <include refid="commonsql"></include>
        where s_age in (
        <foreach collection="ages"----可以用来批量查询
                 item="age" open="(" close=")" separator=",">
            #{age}
        </foreach>
    </select>
 5 <!--批量添加-->
    <insert id="addStuBat" parameterType="map" >
        insert into stu(s_name,s_age,s_birth) VALUES
        <foreach collection="stus" item="stu" separator=",">-----可以用来批量插入
            (#{stu.name},#{stu.age},#{stu.birth})
        </foreach>
    </insert>
```

## mybatis中的代码生成器

```
1 mybatis中的代码生成器，mybatis-generator通过这个来生成-实体类，映射文件
2 生成的映射文件中包括8种sql语句
	1 insert-插入
	2 update by primary key(根据主键更新)
	3 update by example(根据条件更新)
	3 delete by primary key (根据主键删除)
	4 delete by example(根据条件删除)
	5 select by primary key(根据主键查询)
	6 select by example(根据条件查询)
	7 count by example(根据条件查询记录总数)
3 生成接口
```

### [1] 代码生成器的流程

```xml
1 在整个工程的下面，新建一个xml文件。---用来放置一些配置信息
--------------------------------------------------------------------------------------
<generatorConfiguration>
//这里的路径是用来寻找数据库的连接jar包的--连什么数据库，就找什么jar包
  <classPathEntry location="D:\yitupeixun\jar\mysql\mysql-connector-java-5.1.41-bin.jar" />
//这里是数据库连接的驱动，名字，和密码--连接什么数据库，就写什么数据库的驱动
  <context id="DB2Tables" targetRuntime="MyBatis3">
    <jdbcConnection driverClass="com.mysql.jdbc.Driver"
        connectionURL="jdbc:mysql://localhost:3306/book"
        userId="root"
        password="etoak">
    </jdbcConnection>
	//是否强制使用大精度类型--默认是false
    <javaTypeResolver >
      <property name="forceBigDecimals" value="false" />
    </javaTypeResolver>
	//自动生成的实体类，包的路径需要修改,工程的名字需要修改
    <javaModelGenerator targetPackage="com.etoak.book.books.entity" targetProject="Book_m\src">
      <property name="enableSubPackages" value="true" />
      <property name="trimStrings" value="true" />
    </javaModelGenerator>
	//自动生成mapper.xml文件，也是包的路径需要修改,工程的名字需要修改
    <sqlMapGenerator targetPackage="com.etoak.book.books.entity"  targetProject="Book_m\src">
      <property name="enableSubPackages" value="true" />
    </sqlMapGenerator>
	//自动生成dao层的接口，也是包的路径需要修改,工程的名字需要修改
    <javaClientGenerator type="XMLMAPPER" targetPackage="com.etoak.book.books.dao"  targetProject="Book_m\src">
      <property name="enableSubPackages" value="true" />
    </javaClientGenerator>
	//自动生成实体类， 有几个表就生成几个
	schema="book"--数据库的名字
    tableName="category"--表的名字
    domainObjectName="Category"--要生成实体类的名字
    <table schema="book" tableName="category" domainObjectName="Category" >
      <property name="useActualColumnNames" value="true"/>
      <generatedKey column="ID" sqlStatement="select replace(uuid(),'-','') as id" identity="false" />
    </table>
     <table schema="book" tableName="book" domainObjectName="Book" >
      <property name="useActualColumnNames" value="true"/>
      生成主键 生成 主键的生成方式，是否是自动增长
      <generatedKey column="ID" sqlStatement="select replace(uuid(),'-','') as id" identity="false" />
    </table>
    
    <table schema="book" tableName="bookpic" domainObjectName="Bookpic" >
      <property name="useActualColumnNames" value="true"/>
      <generatedKey column="ID" sqlStatement="select replace(uuid(),'-','') as id" identity="false" />
    </table>
	
  </context>
</generatorConfiguration>
```

## mybatis中的面试

```
1 动态标签
     if where foreach sql
2 #(?)  $(字符串 原样输出) like的区别

3 防sql注入的
	select * from 表名 
	where username = ‘etoak’
	and password =    “or 1=1”

4 dbc vs  mybatis  vs hibernate的区别
```

# 2 Spring框架

## 1 Ioc思想(Inversion of Control)

```
1 IOC:控制反转-IOC是一种思想-spring提供了一种IOC思想的实现--》spring的IOC容器(类)
2 控制谁来创建对象的权利-是有一个专门的容器来控制对象的创建
3 反转:由我们创建 到交给IOC容器创建(实力化对象)
4 IOC思想的好处：可以帮助我们管理对象(创建和管理对象 [依赖注入])，帮助我们设计出，松耦合，更加优良的程序，并且更加方便测试。
5 关注点是非核心的，代码重复性高的，但却是必不可少的
6 主从位置上的变化，应用程序原本是老大，要获取什么资源都是主动出击的，但是在IOC思想中，应用程序就变成被动等待容器注入了
----------简单来说--就是类的实例化
```

### [1] 原理

```
1 将所有的Javabean对象统一放入xml配置文件中管理，在xml中以bean元素标签体现出来，并且形成依赖关系
2 容器，创建所有的对象并且形成依赖关系，这种依赖关系在必要的时候注入使用
```

## 2 依赖注入(Dependency Injection)

```
1 组件之间的依赖关系，由容器在运行的期间内决定。
	形象的说，即由容器动态的将某个依赖关系(也可以是值)，注入到某个组件之中。
2 谁依赖谁：应用程序依赖IOC容器
3 为什么要依赖：应用程序需要IOC容器来提供对象的需要的外部资源
4 谁注入谁：IOC容器注入某一个对象，应用程序依赖的对象
5 注入了什么：注入了某个对象所需要的外部资源
---------就是往类中添加数据
```

### [1] 依赖注入的三种方式

#### [1] setter注入

```
1 配置文件的内容
--------------------------------------------------------------
<bean id="stuSetter" class="com.etoak.bean.Student">
	 <property name="id" value="1"></property>
	 <property name="name" value="etoak"></property>
	 <property name="age" value="23"></property>
</bean>
---------------------------还有另一种方式---------------------------
<bean id="student" class="com.etoak.bean.Student">
		<property name="id" value="1"></property>
		<property name="name">
			<value>etoak</value>
		</property>
		<property name="age">
			<value>10</value>
		</property>
	</bean>  
2 测试类中的内容
--------------------------------------------------------------
容器启动-解析配置文件
实例化对象-控制反转
给对象中的属性赋值-依赖注入
ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
ac.start();--有个默认容器启动-不写也可以
获取控制反转的对象(实例化的对象)
Student stu = (Student)ac.getBean("stuSetter");
传入的参数是 bean的id属性
```

##### [1] setter注入多个

```
1 list集合
	<property name="lists">
			<list>
				<value>北京</value>
				<value>上海</value>
				<value>天津</value>
				<value>重庆</value>
			</list>
	</property>
2 map集合
	<property name="maps">
			<map>
				<entry key="etoak" value="易途"></entry>
				<entry key="et" value="et1803"></entry>
				<entry key="李" value="应哈"></entry>
				<entry key="et" value="ok"></entry>
			</map>
	</property>
3 set集合
	<property name="sets">
			<set>
				<value>etoak</value>
				<value>et</value>
				<value>易途</value>
				<value>et1803</value>
			</set>
	</property>
4 引入其他的bean-通过ref
	<property name="stu" ref="student"></property>
```

#### [2] 构造方法注入

##### [1] 参数注入

```
1 配置文件的内容-根据参数的名称方式注入
<bean id="stuName" class="com.etoak.bean.Student">
	<constructor-arg name="id" value="2"></constructor-arg>
	<constructor-arg name="name" value="易途"></constructor-arg>
	<constructor-arg name="age" value="10"></constructor-arg>
</bean>
```

##### [2] 下标注入

```
1 配置文件的内容-根据下标的方式注入-下标从0开始
<bean id="stuIndex" class="com.etoak.bean.Student">
	<constructor-arg index="0" value="3"></constructor-arg>
	<constructor-arg index="1" value="黎英海"></constructor-arg>
	<constructor-arg index="2" value="34"></constructor-arg>
</bean>
```

#### [3]普通的类注入 工厂

```
<bean id="stuFactoryMethod" class="com.etoak.bean.ClassRoom">
	<lookup-method name="getStu" bean="stuSetter"/>
	引入其他的bean-运行加载的话如果加载的是引入的bean，则加载到这的时候，引入的类不用再次加载。如果先加载的		是这个bean，则需要先加载引入的bean，然后在加载这个bean
</bean>
name属性：表示当前bean元素的class属性类中的方法
bean属性：表示引入某个bean元素ID的属性值
```

### [2] Bean的属性

```
1 id属性-获取实例化对象的时候，getBean传入的值
2 class属性-要管理的对象
3 init-method:调用初始化方法
4 destroy-method:调用销毁方法
5 lazy-init："true"懒加载-容器启动的时候不会，实例化对象，只有调用的时候才会，进行实例化，默认是false
6 abstract:"true":设置当前的bean元素为抽象类，抽象类不能被实例化，只能通过另一个Bean来继承
7 parent："继承的抽象类的ID属性"用来继承的，通常和abstract属性组合使用
8 factory-method：静态方法和非静态方法的的名字，和class属性组合的时候就是静态工厂
9 name：可以设置多个别名，和id类似，但是ID只能设置一个
10 factory-bean:引入某个bean元素的ID属性值，和factory-method属性组合的时候，就是实例工厂
```

### [3] 静态的方法和非静态的

```
1 静态的方法-其中必须用constructor-arg
    <bean id="staticParam" class="com.etoak.bean.Student" factory-method="staticParam">
	 	<constructor-arg name="str" value="我是李英海，我要去上学"></constructor-arg>
    </bean>
2 非静态的方法-必须先实例化对象
	<bean id="stuInstance" class="com.etoak.bean.Student"/>
	<bean id="instanceParam" factory-bean="stuInstance" factory-method="instanceParam">
	 	<constructor-arg name="str" value="我是李英海，我饿了"></constructor-arg>
	</bean>
```

## 3 spring的作用域

### [1] singleton(单实例)

```
1 始终保持一个对象，并且在容器启动的时候开始创建
2 配置文件中的内容
	<bean id="stuSingleton" class="com.etoak.bean.Student" scope="singleton" />
	scope不写也可以，默认是单实例的
```

### [2] prototype(非单例)

```
1 每次都会创建一个对象，但是容器启动的时候不会创建，只有在getbean方法被调用的时候，才会创建
2 配置文件中的内容
	<bean id="stuProtoType" class="com.etoak.bean.Student" scope="prototype" />
	这里的scope必须写，而且是非单实例的
```

## 4 Spring的作用

```
1 主要用来整合技术框架(Hibernate，mybatis，struts2)
2 还用来管理Javabean(实例化对象)，实现Java中的代码解耦-降低代码之间的依赖性
3 提供系统扩展性和维护性
```

## 5 Spring的IOC注解

```
51 @Controller("可以取别名"):写在Controller中实例化对象，处理请求和响应。
	相当于<bean id="" class=""/> ID属性别名为类名的首字母小写
2 @Service("可以取别名"):写在Service中，实例化对象，调用Dao层
	相当于<bean id="" class=""/> ID属性别名为类名的首字母小写
3 @Repository("可以取别名"):写在Dao层中，实例化对象
	相当于<bean id="" class=""/> ID属性别名为类名的首字母小写
4 @Component:可以写在Controller，service，dao上，但是最好不用这个注解
-------------------------------写在类名的上边-----------------------
5 @Autowrited：是用来进行依赖注入的，写在类中引入的对象的上边，在使用这个的时候，必须先进行实例化，在进行注入
	1 当@Autowrited匹配的是类名的时候，找类名，也找别名
	2 当@autowrited匹配的是类型的时候，只找类名，不找别名
6 @Qualifier：是用来起别名的，通常用来和@Autowrited配合使用，当引入的对象是一个父类接口，而这个接口又被两	个类实现的时候，通过这个起别名来进行准确的寻找
---------------------------下边这个不是spring中的注解，但是spring也能用------------------------------
1 @Resouce：也是用来注入的。
	1）@Resouce(name="可以取别名")，这种时候，只找别名，别名没有找到抛异常
	2）@Resouce(type=类名.class)，这种时候，只找类型，类型没有找到，抛异常
	3）@Resouce(name="别名",type=类名.class)，这种时候，先找别名再找类型，但是一个都不能写错
```

### [1] 使用注解的时候xml文件中的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:context="http://www.springframework.org/schema/context"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans
	   http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	   http://www.springframework.org/schema/context
	   http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	 <!-- 扫描的是IOC注解 --> 
	 <context:component-scan base-package="com.etoak"/>
</beans>
```

## 6 Spring的aop注解

```
1 @Aspect:声明当前的类是一个切面类或者叫切面，相当于xml格式中的<aop:config>元素
2 @Pointcut("execution(* com.etoak.controller.*.*(..))")
	public void etoak(){}
	定义切入点表达式，etoak方法起到一个过渡的作用  就是为了兼容@Pointcut注解 表示一个切入点
	等价于xml格式中的<aop:pointcut>
3 @Before(value="etoak()") 通知和切入点进行连接组装 aop=通知+切入点,这个注解表示前置通知
4 @AfterReturning(value="etoak()",returning="result") ||
	 通知和切入点进行连接组装 aop=通知+切入点，这个注解表示是后置通知
	 后置通知有可能有返回值
5 @Around(value="etoak()")--组装成一个aop，这个注解表示是环绕通知
6 @AfterThrowing(value="etoak()",throwing="ex")，这个注解表示是异常通知
```

## 7 加载上下文两种方式的区别

```
1 FileSystemXmlApplicationContext：在指定的文件系统的路径下查找xml文件。
2 ClassPathXmlApplicationContext:是在所有的路径下查找xml文件(包含jar文件)
```

## 8 Spring的用注解代替xml文件

```java 
/**
 * @Configuration将当前对象实例化
 *               替代xml配置文件
 *               等价xml配置文件中<beans>元素
 */
@Configuration
public class SpringConfig {
	/**
	 * @Bean等价xml配置文件中<bean>元素
	 *          方法的返回值就spring要实例化的对象 默认为单例
	 *          如果该方法不加@Bean注解，调用该方法时表示没有交给spring管理
	 *          每次都会实例化一个新的内存地址
	 *          默认别名为方法名称   区分大小写 例如 getStu
	 *          自定义别名
	 *          例如  @Bean(name="stu")
	 */
	@Scope("prototype")
	@Bean(name="stu")
	public Student getStu() {
		//实例化对象
		Student stu = new Student();
		//setter方法注入
		stu.setId(1);
		stu.setName("易途");
		stu.setAge(10);
		//spring通过返回值来实例化对象
		return stu;
	}
}
```

